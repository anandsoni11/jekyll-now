---
layout: post
title: One year. Such legacy. Much learning 
category: binary
---
It all started (almost) a year ago, in August 2015. I was about to graduate and I had joined Intuit India as a software engineer. Moving out from college to the (professional) world was a big deal. It is metaphorical to a kid starting school with a clean slate in his bag, after a few years of utter playfulness and learning at home!

So, this is all about the one year that I have spent in the industry and what it has taught me. Its not about my achievments but about my learnings. So, back to the starting. **When you start with a clean slate, what motivates you even to start?** For me, it has always been conviction. And holding up this conviction has proved to be wondrous.     

### **What have I learnt?** 

In the last one year, I have played my part in team(s) working on QuickBooks Desktop, a legacy Intuit product. There is a reason we call it *"legacy"*. It is validated knowledge that stood the tough tests of time and still answers to very precise needs. But, when a legacy system is maintained (over years), it loses on contemporary advances in technology; it clings to *legacy* technologies, exhibiting non-decreasing complexity. The takeaway (for me) being, legacy systems not only need to be maintained but also need to be gradually reengineered (equivalent to preserving the legacy). 

But, that's not it. There is much more to it than can be told. Some very important learnings come to my mind on reminiscence. 

### **Take the next step, always** 

Nothing is more satisfying for the human mind than the ecstacy of a hard-earned success. Think of the time when you had a ***catch me if you can*** match devising an algorithm or debugging your own code (not that hard to imagine, right?). Remember the enormous joy of winning *the match* after, say, 20 hours of such a spectacular tussle. Now, imagine giving up on it just a minute before. Disaster. That's the beauty of programming (and of life). *You are never more than a step away from success*. Go take the next step, always.     

### **Ask dumb questions**

Many of us have tough time asking questions. Believe me, there's always a way out. As opposed to popular belief, **ignorance is not bliss**. Ever since I started my career in this industry, I have tried to ask enough dumb questions and that has helped me understand things a lot better. If it helps, understand that no question is actually dumb. Remember *Newton* asking to himself, *why did the apple fall down?*? A word of advice, *suit yourselves* before asking dumb questions!


### **Solve problems. Never shy away from challenges**

Ever heard of the [*Ostrich effect*](https://en.wikipedia.org/wiki/Ostrich_effect)? It is a widely believed concept (factually incorrect) that in the face of danger, ostriches bury their head in the sand expecting to remain unharmed as the danger passes them by. One important lesson to learn and fortify here is that, we should never be like a (folklore) ostrich! In fact, **the pivotal idea of programming and engineering as a whole is to solve problems**, not to hide away. And how do you solve problems, again?

> There are only two ways to solve a problem: stop dwelling, and start doing.



### **We are Antifragile**

Recently, I happened to come across the profound idea of *antifragility*. As *Nassim Nicholas Taleb* describes in his book *Antifragile*, **antifragile is something that gains out of chaos and disorder**. It is the exact opposite of fragile. If I were to describe it, I would say, it is **resilience meets learning**.

The point? **Software applications**, in my humble opinion, **are inherently anti-fragile**. If seen wearing the lenses of an optimist, *the more the loopholes identified, the more the chaos and the better the application becomes* (as loopholes are fixed and filled). In other words, in the whole engineering life cycle, a software goes under fixes, redesigns and revamps and such chaos makes it better and better. Similarly, **we, who innately love to solve problems are antifragile**. The more the problems, the more we solve and the more we solve, the better we get. Food for thought.

### **Be insecure. Delve into the unknown**

> If you are not a little scared, you are not doing it right.

When a problem, at large, stares us, right into the face, one of two things always happens. Either we know the solution or we don't know the solution (yet). Problems where the former happens lie in the zone of *comfort* and *surity*. It is those problems, where the later happens are the ones all of us should look up to. Why? Because they lie in the domain of the *unknown*. **In this domain, we learn, innovate, win and (sometimes) fail**. In this domain, we can be anything from *not so sure* or *little scared* to *vulnerable*. And as we are antifragile, we thrive in this domain!    

### **Make mistakes. Fail**

> Why do we fall? So that we can learn to pick ourselves up.

Has there been a single programmer on the face of the Earth who never has seen a syntax error? I am sure not. Each big step succeeds many small ones. We all start with the *Hello worlds*. And then we learn. We learn from ours and from others' mistakes. If there were no mistakes, there would not be any learning. A world without mistakes would be dumb.

Looking back, I see twelve months of great learnings. If anything, that's what that matters. The list doesn't end here, though. Of course, the post does!  

